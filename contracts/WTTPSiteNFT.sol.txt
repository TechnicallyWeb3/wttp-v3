// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./test/TestSite.sol";
import "./interfaces/IDataPointRegistryV2.sol";

/// @title WTTP Site Ownership NFT
/// @notice NFT that represents ownership of a WTTP site, deploying sites and transferring admin rights
/// @dev Extends ERC721 with enumerable and URI storage for site metadata
contract WTTPSiteNFT is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable {
    // Store WTTP site contracts linked to each token ID
    mapping(uint256 => address) public tokenSites;
    
    // DPR address for site deployments
    address public dprAddress;
    
    // Default header for new sites
    HeaderInfo public defaultHeader;
    
    // Max supply of tokens
    uint256 public constant MAX_SUPPLY = 10000;
    
    // Track the next available token ID
    uint256 private _nextTokenId = 1;
    
    // Events
    event SiteDeployed(uint256 indexed tokenId, address indexed siteAddress, address indexed owner);
    
    constructor(address _dprAddress, HeaderInfo memory _defaultHeader) 
        ERC721("WTTP Site Ownership", "WTTP") 
        Ownable(msg.sender) 
    {
        dprAddress = _dprAddress;
        defaultHeader = _defaultHeader;
    }
    
    /// @notice Deploys a new site and mints an NFT representing its ownership
    /// @param to Address receiving the NFT and site ownership
    /// @param siteMetadataURI URI for the site's metadata
    /// @return tokenId The ID of the new token
    function deployAndMintSite(address to, string memory siteMetadataURI) external returns (uint256 tokenId) {
        require(_nextTokenId <= MAX_SUPPLY, "Max supply reached");
        tokenId = _nextTokenId++;
        
        // Deploy a new WTTP site with the token recipient as the owner
        WTTPSiteV3 newSite = new TestSite(dprAddress, to, defaultHeader);
        
        // Store the site contract reference
        tokenSites[tokenId] = address(newSite);
        
        // Mint the token and set its metadata
        _mint(to, tokenId);
        _setTokenURI(tokenId, siteMetadataURI);
        
        emit SiteDeployed(tokenId, address(newSite), to);
        
        return tokenId;
    }
    
    /// @notice Override to add automatic site ownership transfer
    function transferFrom(address from, address to, uint256 tokenId) public override(ERC721, IERC721) {
        // Get reference to WTTP site before transferring the token
        address siteAddress = tokenSites[tokenId];
        
        // Call parent implementation for the NFT transfer
        super.transferFrom(from, to, tokenId);
        
        // Transfer site ownership to new token owner
        if (siteAddress != address(0)) {
            WTTPSiteV3(siteAddress).transferOwnership(to);
        }
    }
    
    /// @notice Override to add automatic site ownership transfer
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) 
        public 
        override(ERC721, IERC721) 
    {
        // Get reference to WTTP site before transferring the token
        address siteAddress = tokenSites[tokenId];
        
        // Call parent implementation for the NFT transfer
        super.safeTransferFrom(from, to, tokenId, data);
        
        // Transfer site ownership to new token owner
        if (siteAddress != address(0)) {
            WTTPSiteV3(siteAddress).transferOwnership(to);
        }
    }
    
    /// @notice Updates DPR address for future site deployments
    function updateDPRAddress(address _dprAddress) external onlyOwner {
        dprAddress = _dprAddress;
    }
    
    /// @notice Updates default header for future site deployments
    function updateDefaultHeader(HeaderInfo memory _defaultHeader) external onlyOwner {
        defaultHeader = _defaultHeader;
    }
    
    // Required overrides for multiple inheritance
    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }
    
    function _increaseBalance(address account, uint128 value)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._increaseBalance(account, value);
    }
    
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
} 